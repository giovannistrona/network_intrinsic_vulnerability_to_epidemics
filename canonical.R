###R code to run Canonical Correlation Analysis, PCA and produce figures; run this after you have run the python scripts 'experiment_real.py', 'experiment_sim.py' and 'test_SIR_rank.py'


##make violin plots of network properties

require(ggplot2)

multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  require(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}


a <- read.csv("results_sim.csv", header=T)


p0<-ggplot(data=a,aes(x='Nodes',y=vvv))+geom_violin(alpha=0.6)+ theme(axis.text.x=element_text(colour="black",size=0))+ theme(axis.text.y=element_text(colour="black",size=20))+ theme(axis.line = element_line(colour = 'black', size = 1, linetype = 'solid')) + theme(axis.title=element_text(size=20,face="bold"))+theme(axis.ticks=element_line(colour='black',size=1))+ theme(legend.position="none")+stat_summary(fun.y=mean, fun.ymin=mean, fun.ymax=mean,geom="point", size=3,colour='black')+stat_summary(fun.y=median, fun.ymin=median, fun.ymax=median,geom="crossbar", width=0.5,colour='black')+ ylab('')

p1<-ggplot(data=a,aes(x='Edges',y=eee))+geom_violin(alpha=0.6)+ theme(axis.text.x=element_text(colour="black",size=0))+ theme(axis.text.y=element_text(colour="black",size=20))+ theme(axis.line = element_line(colour = 'black', size = 1, linetype = 'solid')) + theme(axis.title=element_text(size=20,face="bold"))+theme(axis.ticks=element_line(colour='black',size=1))+ theme(legend.position="none")+stat_summary(fun.y=mean, fun.ymin=mean, fun.ymax=mean,geom="point", size=3,colour='black')+stat_summary(fun.y=median, fun.ymin=median, fun.ymax=median,geom="crossbar", width=0.5,colour='black')+ ylab('')

p2<-ggplot(data=a,aes(x='Connectance',y=conn))+geom_violin(alpha=0.6)+ theme(axis.text.x=element_text(colour="black",size=0))+ theme(axis.text.y=element_text(colour="black",size=20))+ theme(axis.line = element_line(colour = 'black', size = 1, linetype = 'solid')) + theme(axis.title=element_text(size=20,face="bold"))+theme(axis.ticks=element_line(colour='black',size=1))+ theme(legend.position="none")+stat_summary(fun.y=mean, fun.ymin=mean, fun.ymax=mean,geom="point", size=3,colour='black')+stat_summary(fun.y=median, fun.ymin=median, fun.ymax=median,geom="crossbar", width=0.5,colour='black')+ ylab('')

p3<-ggplot(data=a,aes(x='Clustering',y=clust))+geom_violin(alpha=0.6)+ theme(axis.text.x=element_text(colour="black",size=0))+ theme(axis.text.y=element_text(colour="black",size=20))+ theme(axis.line = element_line(colour = 'black', size = 1, linetype = 'solid')) + theme(axis.title=element_text(size=20,face="bold"))+theme(axis.ticks=element_line(colour='black',size=1))+ theme(legend.position="none")+stat_summary(fun.y=mean, fun.ymin=mean, fun.ymax=mean,geom="point", size=3,colour='black')+stat_summary(fun.y=median, fun.ymin=median, fun.ymax=median,geom="crossbar", width=0.5,colour='black')+ ylab('')

p4<-ggplot(data=a,aes(x='Diameter',y=diam))+geom_violin(alpha=0.6)+ theme(axis.text.x=element_text(colour="black",size=0))+ theme(axis.text.y=element_text(colour="black",size=20))+ theme(axis.line = element_line(colour = 'black', size = 1, linetype = 'solid')) + theme(axis.title=element_text(size=20,face="bold"))+theme(axis.ticks=element_line(colour='black',size=1))+ theme(legend.position="none")+stat_summary(fun.y=mean, fun.ymin=mean, fun.ymax=mean,geom="point", size=3,colour='black')+stat_summary(fun.y=median, fun.ymin=median, fun.ymax=median,geom="crossbar", width=0.5,colour='black')+ ylab('')

p5<-ggplot(data=a,aes(x='Reciprocity',y=rec))+geom_violin(alpha=0.6)+ theme(axis.text.x=element_text(colour="black",size=0))+ theme(axis.text.y=element_text(colour="black",size=20))+ theme(axis.line = element_line(colour = 'black', size = 1, linetype = 'solid')) + theme(axis.title=element_text(size=20,face="bold"))+theme(axis.ticks=element_line(colour='black',size=1))+ theme(legend.position="none")+stat_summary(fun.y=mean, fun.ymin=mean, fun.ymax=mean,geom="point", size=3,colour='black')+stat_summary(fun.y=median, fun.ymin=median, fun.ymax=median,geom="crossbar", width=0.5,colour='black')+ ylab('')


p6<-ggplot(data=a,aes(x='Spectral Radius',y=eig))+geom_violin(alpha=0.6)+ theme(axis.text.x=element_text(colour="black",size=0))+ theme(axis.text.y=element_text(colour="black",size=20))+ theme(axis.line = element_line(colour = 'black', size = 1, linetype = 'solid')) + theme(axis.title=element_text(size=20,face="bold"))+theme(axis.ticks=element_line(colour='black',size=1))+ theme(legend.position="none")+stat_summary(fun.y=mean, fun.ymin=mean, fun.ymax=mean,geom="point", size=3,colour='black')+stat_summary(fun.y=median, fun.ymin=median, fun.ymax=median,geom="crossbar", width=0.5,colour='black')+ ylab('')

p7<-ggplot(data=a,aes(x='Robustness',y=rob))+geom_violin(alpha=0.6)+ theme(axis.text.x=element_text(colour="black",size=0))+ theme(axis.text.y=element_text(colour="black",size=20))+ theme(axis.line = element_line(colour = 'black', size = 1, linetype = 'solid')) + theme(axis.title=element_text(size=20,face="bold"))+theme(axis.ticks=element_line(colour='black',size=1))+ theme(legend.position="none")+stat_summary(fun.y=mean, fun.ymin=mean, fun.ymax=mean,geom="point", size=3,colour='black')+stat_summary(fun.y=median, fun.ymin=median, fun.ymax=median,geom="crossbar", width=0.5,colour='black')+ ylab('')


pdf('net_props.pdf',height=6,width=12, useDingbats=F)

multiplot(p0,p4,p1,p5,p2,p6,p3,p7,cols=4)

dev.off()


#################
###############Canonical Correlation analysis in the SIMULATED dataset


library(yacca)


a<-read.csv('results_sim.csv',header=T)

attach(a)


X<-a[,c("conn","rec","vvv","eee","eig","VU","diam","clust","rob","resistance","death","transmission_rate")]
Y<-a[,c("I","II","III","IV","V")]
for (col in seq(1:dim(X)[2]))(X[,col]<-(X[,col]-mean(X[,col]))/sd(X[,col]))
for (col in seq(1:dim(Y)[2]))(Y[,col]<-(Y[,col]-mean(Y[,col]))/sd(Y[,col]))
res<-cca(X,Y)






sink('Canonical_RES.txt')
c('Correlation',as.matrix(res$corr)[1],as.matrix(res$corr)[2])
c('Root',as.matrix(res$corrsq)[1],as.matrix(res$corrsq)[2])
c('Redundancy',as.matrix(res$yvrd)[1],as.matrix(res$yvrd)[2])
c('F test',F.test.cca(res)[2]$statistic)
c('F',F.test.cca(res)[3]$parameter[,1])
c('Pr(>F)',F.test.cca(res)[4]$p.value)
c(colnames(X)[1],as.matrix(res$xcrosscorr)[1,1],as.matrix(res$xcrosscorr)[1,2])
c(colnames(X)[2],as.matrix(res$xcrosscorr)[2,1],as.matrix(res$xcrosscorr)[2,2])
c(colnames(X)[3],as.matrix(res$xcrosscorr)[3,1],as.matrix(res$xcrosscorr)[3,2])
c(colnames(X)[4],as.matrix(res$xcrosscorr)[4,1],as.matrix(res$xcrosscorr)[4,2])
c(colnames(X)[5],as.matrix(res$xcrosscorr)[5,1],as.matrix(res$xcrosscorr)[5,2])
c(colnames(X)[6],as.matrix(res$xcrosscorr)[6,1],as.matrix(res$xcrosscorr)[6,2])
c(colnames(X)[7],as.matrix(res$xcrosscorr)[7,1],as.matrix(res$xcrosscorr)[7,2])
c(colnames(X)[8],as.matrix(res$xcrosscorr)[8,1],as.matrix(res$xcrosscorr)[8,2])
c(colnames(X)[9],as.matrix(res$xcrosscorr)[9,1],as.matrix(res$xcrosscorr)[9,2])
c(colnames(X)[10],as.matrix(res$xcrosscorr)[10,1],as.matrix(res$xcrosscorr)[10,2])

c(colnames(Y)[1],as.matrix(res$ycrosscorr)[1,1],as.matrix(res$ycrosscorr)[1,2])
c(colnames(Y)[2],as.matrix(res$ycrosscorr)[2,1],as.matrix(res$ycrosscorr)[2,2])
c(colnames(Y)[3],as.matrix(res$ycrosscorr)[3,1],as.matrix(res$ycrosscorr)[3,2])
c(colnames(Y)[4],as.matrix(res$ycrosscorr)[4,1],as.matrix(res$ycrosscorr)[4,2])
c(colnames(Y)[5],as.matrix(res$ycrosscorr)[5,1],as.matrix(res$ycrosscorr)[5,2])

sink()



###############Canonical Correlation analysis in the REAL dataset (i.e. field vole contact networks)

detach(a)
a<-read.csv('results_real.csv',header=T)
attach(a)


X<-a[,c("conn","vvv","eee","eig","diam","clust","rob","resistance","death","transmission_rate")]
Y<-a[,c("I","II","III","IV","V")]
for (col in seq(1:dim(X)[2]))(X[,col]<-(X[,col]-mean(X[,col]))/sd(X[,col]))
for (col in seq(1:dim(Y)[2]))(Y[,col]<-(Y[,col]-mean(Y[,col]))/sd(Y[,col]))

res<-cca(X,Y)



sink('Canonical_RES_real.txt')
c('Correlation',as.matrix(res$corr)[1],as.matrix(res$corr)[2])
c('Root',as.matrix(res$corrsq)[1],as.matrix(res$corrsq)[2])
c('Redundancy',as.matrix(res$yvrd)[1],as.matrix(res$yvrd)[2])
c('F test',F.test.cca(res)[2]$statistic)
c('F',F.test.cca(res)[3]$parameter[,1])
c('Pr(>F)',F.test.cca(res)[4]$p.value)
c(colnames(X)[1],as.matrix(res$xcrosscorr)[1,1],as.matrix(res$xcrosscorr)[1,2])
c(colnames(X)[2],as.matrix(res$xcrosscorr)[2,1],as.matrix(res$xcrosscorr)[2,2])
c(colnames(X)[3],as.matrix(res$xcrosscorr)[3,1],as.matrix(res$xcrosscorr)[3,2])
c(colnames(X)[4],as.matrix(res$xcrosscorr)[4,1],as.matrix(res$xcrosscorr)[4,2])
c(colnames(X)[5],as.matrix(res$xcrosscorr)[5,1],as.matrix(res$xcrosscorr)[5,2])
c(colnames(X)[6],as.matrix(res$xcrosscorr)[6,1],as.matrix(res$xcrosscorr)[6,2])
c(colnames(X)[7],as.matrix(res$xcrosscorr)[7,1],as.matrix(res$xcrosscorr)[7,2])
c(colnames(X)[8],as.matrix(res$xcrosscorr)[8,1],as.matrix(res$xcrosscorr)[8,2])
c(colnames(X)[9],as.matrix(res$xcrosscorr)[9,1],as.matrix(res$xcrosscorr)[9,2])
c(colnames(X)[10],as.matrix(res$xcrosscorr)[10,1],as.matrix(res$xcrosscorr)[10,2])

c(colnames(Y)[1],as.matrix(res$ycrosscorr)[1,1],as.matrix(res$ycrosscorr)[1,2])
c(colnames(Y)[2],as.matrix(res$ycrosscorr)[2,1],as.matrix(res$ycrosscorr)[2,2])
c(colnames(Y)[3],as.matrix(res$ycrosscorr)[3,1],as.matrix(res$ycrosscorr)[3,2])
c(colnames(Y)[4],as.matrix(res$ycrosscorr)[4,1],as.matrix(res$ycrosscorr)[4,2])
c(colnames(Y)[5],as.matrix(res$ycrosscorr)[5,1],as.matrix(res$ycrosscorr)[5,2])

sink()





####SQUARE PLOTS
####make square plots permitting comparison of the canonical loadings

can_res <- c()
xvars <- c("vvv","eee","conn","eig","diam","clust","rob","resistance","death","transmission_rate")
yvars <- c("I","II","III","IV","V")
a<-read.csv('results_sim.csv',header=T)
attach(a)


X<-a[,xvars]
Y<-a[,yvars]
for (col in seq(1:dim(X)[2]))(X[,col]<-(X[,col]-mean(X[,col]))/sd(X[,col]))
for (col in seq(1:dim(Y)[2]))(Y[,col]<-(Y[,col]-mean(Y[,col]))/sd(Y[,col]))
res<-cca(X,Y)


if (res$ycrosscorr[1,1]>0 | res$ycrosscorr[2,1]>0 | res$ycrosscorr[3,1]>0){can_res<-rbind(can_res,res$xcrosscorr[,1])} else {can_res<-rbind(can_res,-res$xcrosscorr[,1])}	



for (type in c('WS','BAR','ER','CONF1','CONF2'))
	{
		b<-a[a$graph_type==type,]
		X<-b[,xvars]
		Y<-b[,yvars]
		for (col in seq(1:dim(X)[2]))(X[,col]<-(X[,col]-mean(X[,col]))/sd(X[,col]))
		for (col in seq(1:dim(Y)[2]))(Y[,col]<-(Y[,col]-mean(Y[,col]))/sd(Y[,col]))
		res<-cca(X,Y)
		#print (res$corrsq)
		if (res$ycrosscorr[1,1]>0 | res$ycrosscorr[2,1]>0 | res$ycrosscorr[3,1]>0){can_res<-rbind(can_res,res$xcrosscorr[,1])} else {can_res<-rbind(can_res,-res$xcrosscorr[,1])}	
	

	}


detach(a)
a<-read.csv('results_real.csv',header=T)
attach(a)


X<-a[,xvars]
Y<-a[,yvars]
for (col in seq(1:dim(X)[2]))(X[,col]<-(X[,col]-mean(X[,col]))/sd(X[,col]))
for (col in seq(1:dim(Y)[2]))(Y[,col]<-(Y[,col]-mean(Y[,col]))/sd(Y[,col]))

res<-cca(X,Y)
if (res$ycrosscorr[1,1]>0 | res$ycrosscorr[2,1]>0 | res$ycrosscorr[3,1]>0){can_res<-rbind(can_res,res$xcrosscorr[,1])} else {can_res<-rbind(can_res,-res$xcrosscorr[,1])}

row.names(can_res)<-c('Simulated-All','WS','BAR','ER','CONF1','CONF2','REAL')
labels_x<-c("nodes","edges","conn","SR","diam","clust","R",expression(iota),expression(rho),expression(tau))
 



library(adegraphics)

pdf('canonical_loadings.pdf')
table.value(can_res,labelsx = labels_x)
dev.off()


#####compare Robustness with the five epidemic measures in both real and simulated data
detach(a)
a<-read.csv('results_sim.csv',header=T)
b<-read.csv('results_real.csv',header=T)


cols<-c('#d95f02','#7570b3','#e7298a','#66a61e','#e6ab02','#a6761d','#666666')

pdf('robustness_vs_epidemic_measures.pdf',height=6,width=15)

par(mfrow=c(2,5))

for (i in 14:18){
boxplot(a[,i]~round(a[,12],1),boxwex=0.4,outline=F,col=cols[1],cex.axis=1.4,cex.lab=2,  xlab = "Robustness",las=1,main=colnames(a)[i])
ccc<-round(cor(a[,i],a[,12],method='spearman'),2)
text(2,mean(a[,i])*1.5,bquote(paste(Rs,' = ',.(ccc))),cex=1)

}

for (i in 14:18){
boxplot(b[,i]~round(b[,12],1),boxwex=0.4,outline=F,col=cols[2],cex.axis=1.4,cex.lab=2,  xlab = "Robustness",las=1,main=colnames(b)[i])
ccc<-round(cor(b[,i],b[,12],method='spearman'),2)
text(2,mean(b[,i])*1.5,bquote(paste(Rs,' = ',.(ccc))),cex=1)
}
dev.off()


#####Unique Robustness as a measure of intrinsic network vulnerability to epidemics 
library(ggplot2)
library(viridis)
library(hexbin)

ylabel <- "Robustness"
xlabel <- "Infected Nodes"
a<-read.csv('RANK_sir.csv',header=F)
#b<-a[a[,3]>0.2 | a[,4] > 0.2,]
#a<-b[b[,3]<0.8 | b[,4] < 0.8,]

pdf('robustness_vs_vulnerability.pdf')
ggplot(a,aes(a[,1],a[,2]))+geom_hex(bins=20)+coord_fixed()+scale_fill_distiller(palette="Blues",trans="reverse")+theme(axis.text.x=element_text(colour="black",size=20))+ theme(axis.text.y=element_text(colour="black",size=20))+ theme(axis.line = element_line(colour = 'black', size = 1, linetype = 'solid')) + theme(axis.title=element_text(size=20,face="bold"))+theme(axis.ticks=element_line(colour='black',size=1))+ xlab(xlabel) + ylab(ylabel)

dev.off()

####PCA comparing topological properties of simulated vs. real (i.e. field vole) networks; you need to run the python script 'make_pca_dataset.py' to obtain the file 'for_pca.csv'

###PCA
library(vegan)
library(ggplot2)
a<-read.csv('for_pca.csv',header=T,row.names=1)

pc<-princomp(a[,1:7],scores=T)
data.scores <- as.data.frame(pc$scores[,1:2])

data.scores$site <- rownames(data.scores)  # create a column of site names, from the rownames of data.scores
data.scores$grp <- a[,8]  #  add the grp variable created earlier


grp.sim <- data.scores[data.scores$grp == "simulated", ][chull(data.scores[data.scores$grp == "simulated", c("Comp.1", "Comp.2")]), ]
grp.real <- data.scores[data.scores$grp == "real", ][chull(data.scores[data.scores$grp == "real", c("Comp.1", "Comp.2")]), ]


hull.data <- rbind(grp.sim,grp.real)  #combine grp.a and grp.b


p=ggplot() +geom_point(data=data.scores,aes(x=Comp.1,y=Comp.2,colour=grp),size=2,alpha=0.5) + geom_polygon(data=hull.data,aes(x=Comp.1,y=Comp.2,fill=grp,group=grp),alpha=0.5) + theme_bw()+ scale_color_manual(values=c('darkblue','magenta'))+scale_fill_manual(values=c('darkblue','magenta'))

ggsave(p, file="pca.pdf", width=4.5, height=4.5,useDingbats=F)


