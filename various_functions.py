from numpy import zeros,trapz,ones
from igraph import Graph
from numpy import mean,std,array,arange
from load import csv_
from random import sample, shuffle,randint,randrange,random
from scipy.stats import truncnorm
from numpy.random import lognormal
from numpy.linalg import eigvals
import networkx as nx



def GH(g):
	return max(eigvals(array(list(g.get_adjacency()))))
 




def rec_sc(L):
	sc0=0
	un=[]
	for i in L:
		if i[::-1] in L:
			sc0+=1
		if i[::-1] not in un:
			un.append(i)
	sc0/=2.0*float(len(un))
	return sc0




def make_rec(l,p):
	L=l[:]
	shuffle(L)
	un=[]
	sc0=0
	for i in L:
		if i[::-1] in L:
			sc0+=1
		if i[::-1] not in un:
			un.append(i)
	sc0/=2.0*float(len(un))
	p-=sc0
	if p>0:
		sc=round(p*len(un))
		d=0
		while d<sc:
			e=sample(un,1)[0]
			if e[::-1] not in L:
				L.append(e[::-1])
				d+=1
	else:
		sc=round(abs(p)*len(un))
		d=0
		while d<sc:
			e=sample(un,1)[0]
			if e[::-1] in L:
				L.remove(e[::-1])
				d+=1
	return L






def make_list(L):
	g=Graph.TupleList(L,directed=True)
	a=g.get_adjlist(mode='OUT')
	rl,II,aa=[],[],[]
	for i in range(len(a)):
		if a[i]!=[]:
			rl.append(i)
			aa.append(a[i]) 
		else:
			II.append(i)
	I=rl+II
	dictionary = dict(zip(I, range(len(I))))
	RL=[]
	for i in aa:
		RL.append([dictionary[j] for j in i])
	return RL





def R_pr(a):
	#aa=Graph(a,directed=True)
	aa=Graph(a)
	n=float(aa.vcount())
	sc=0
	maxp=0
	for rep in range(1,int(n)+1):
		try:
			dg=aa.pagerank()
			DG=dg.index(max(dg))
			aa.delete_vertices(DG)
			sc+=max([len(i) for i in aa.clusters(mode='weak')])/n
		except:
			pass
			#print aa.vcount()
		maxp+=(n-rep)/n
	return sc/n,maxp/n #,n,(maxp-sc)/(maxp-1),








def config(nnn,gamma):
	a=[]
	while len(a)<nnn:
	    nextval = int(nx.utils.powerlaw_sequence(1, gamma)[0])
	    if nextval!=0:
		a.append(nextval)
	G = nx.configuration_model(a)
	G=nx.Graph(G) # remove parallel edges
	G.remove_edges_from(G.selfloop_edges())
	return G





def make_g(t):
	if t==1:
		ws1,ws2,ws3,ws4=1,randrange(50,250),randrange(2,10),random()
		b=Graph.Watts_Strogatz(ws1,ws2,ws3,ws4)
		name='WS_'+'_'.join(map(str,[ws1,ws2,ws3,ws4]))
	if t==2:
		bar1=randrange(500,1000)
		bar2=int(round(bar1*0.01*random()))+1
		b=Graph.Barabasi(bar1,[randrange(bar2) for i in range(bar1)])
		name='BAR_'+'_'.join(map(str,[bar1,bar2]))
	if t==3:
		er1=randrange(50,500)
		er2=randrange(er1,1000)
		b=Graph.Erdos_Renyi(n=er1, m=er2, directed=False, loops=False)
		name='ER_'+'_'.join(map(str,[er1,er2]))
	if t==4:
		nnn=randrange(50,500)
		gamma=randrange(200,300)/100.0
		ok='no'
		while ok=='no':
			try:
				b=config(nnn,gamma)
				ok='yes'
			except:
				pass
		if gamma>2.5:
			name='CONF1_'+'_'.join(map(str,[nnn,gamma]))
		else:
			name='CONF2_'+'_'.join(map(str,[nnn,gamma]))
#		la1,la2,la3=randrange(5,25),randrange(5,25),randrange(1,5)
#		b=Graph.Lattice([la1,la2], nei=la3, directed=True, mutual=True, circular=True)
#		name='LAT_'+'_'.join(map(str,[la1,la2,la3]))
	if t!=4:
		g=[list(i.tuple) for i in b.es]
	else:
		g=[list(i) for i in b.edges()]	
	#print len(g)
	rec=round(random(),1)
	gg=make_rec(g,rec)
	b=Graph.TupleList(gg,directed=True)
	vvv,eee,diam,clust=b.vcount(),b.ecount(),b.diameter(),b.transitivity_undirected()
	eig=GH(b)
	rob,rob_max=R_pr(g)
	return g,name.split('_')[0],'_'.join(name.split('_')[1:]),float(eig),vvv,eee,diam,clust,rob,rob_max,rec






def ep(l,susc_,resistance=0.9,death=0,TR=0.5,REP=100,worst='no'):
	SC=[]
	if worst=='yes':
		imm=len(susc_)-len(l)		#number of nodes not having incoming links, thus immune to infection
		lll=[len(i) for i in l]
		lmax=lll.index(max(lll))
	nodes=float(max([max(i) for i in l]))
	for rep in range(REP):		#infection spread is simulated 100 times
		susc_copy=susc_[:]
		if worst=='yes':
			INF=[lmax]	#infection starts from the node with highest degree 
		else:
			INF=[randrange(len(l))]	#infection starts at random from a node having out-going links		
		sc=0
		n_INF=[]
		INF_sc=ones(int(nodes)+1)
		vuln=[]
		for i in l:
			vuln+=i
		vuln=set(vuln)
		VU=float(len(set(vuln)))
		INF_tot=[]	
		while INF!=[]:		#stops when infection stops spreading or when all susceptible nodes are infected
			n_INF.append(len(set([i for i in INF]))/nodes)		#instead of VU number of infections per cycle
			INF_new=[]
			INF_=[]
			for inf in INF:
				INF_tot.append(inf)
				if random()>(1-1/float(INF_sc[inf]**death)):
				#if random()>death or sc<1:
					INF_.append(inf)
					INF_sc[inf]+=1
				else:
					INF_sc[inf]=1
				if inf<len(l):		#if the infected has out-going links
					for k in sample(l[inf],len(l[inf])):
						if random()<=susc_copy[k]*TR: #nodes linked to the infected one are infected according to probability susc_copy[k] multiplied by transmission rate TR
							INF_.append(k)
							susc_copy[k]*=resistance #node k gains resistance to infection according to parameter 'resistance'
			INF_=list(set(INF_))
			INF=sample(INF_,len(INF_))
			#print INF
			sc+=1	#infection cycles counter
		SC.append([sc,len(set(INF_tot))/nodes,max(n_INF),mean(n_INF),trapz(n_INF,arange(0,(1+1/float(len(n_INF)-1)),1/float(len(n_INF)-1))[:len(n_INF)]),VU])
	return(list(mean(SC,axis=0)))





aaa=[lognormal(mean=0,sigma=0.3) for i in range(10000)]
log_norm=[1-(max(aaa)-i)/(max(aaa)-min(aaa)) for i in aaa]

from numpy.random import normal

def make_susc(g,mode='equi'):		#adj_list
	vvv=[]
	for i in range(len(g)):
		vvv+=g[i]+[i]
	outd=[len(i) for i in g]+[0 for i in range(len(vvv)-len(g))]
	ind=[len([1 for i in g if j in i]) for j in vvv]
	deg=[outd[i]+ind[i] for i in range(len(vvv))]
	md,Md=min(deg),max(deg)
	if mode=='equi':
		susc=[random() for i in range(len(set(vvv)))]
	elif mode=='unif':
		#p=random()
		p=0.5
		susc=[p for i in range(len(set(vvv)))]
	elif mode=='norm':
		susc=[normal(0.5,0.1) for i in range(len(set(vvv)))]
	elif mode=='lognorm':
		susc=[sample(log_norm,1)[0] for i in range(len(set(vvv)))]
	elif mode=='lognorm_rev':
		susc=[1-sample(log_norm,1)[0] for i in range(len(set(vvv)))]
	elif mode=='deg':
		susc=[(Md-deg[i])/float(Md-md) for i in range(len(deg))]
	elif mode=='deg_rev':
		susc=[1-(Md-deg[i])/float(Md-md) for i in range(len(deg))]
	return susc


